
# WBServices Pattern — Architecture & Usage

## Overview

WBServices is the central service registry and initialization pattern for all components in the wb-starter v3.0 architecture. It ensures every component uses Light DOM, proper HTMLElement inheritance, and ES Modules, while providing a unified way to register, initialize, and share services or logic across components.

---

## Key Principles

- **Central Registry:** All components and services are registered via `WBServices.register()`.
- **No Shadow DOM:** Components render in Light DOM for full CSS cascade and accessibility.
- **Proper Inheritance:** Components extend HTMLElement directly, not a custom base class.
- **Schema-Driven:** Each component has a JSON schema describing its properties and structure.
- **ES Modules Only:** All logic is imported/exported using ESM syntax.

---

## How It Works

1. **Registration:**
   - Each component or service calls `WBServices.register(name, definition)`.
   - This adds the component/service to the central registry.

2. **Initialization:**
   - On page load, the bootstrapper scans the DOM for `<wb-*>` tags.
   - For each, it loads the schema, logic, and styles, then registers the custom element if not already present.
   - Shared services (e.g., event bus, theme manager) are also registered and injected as needed.

3. **Usage in Components:**
   - Components can access shared services via the registry, e.g. `WBServices.get('theme')`.
   - This enables dependency injection and loose coupling between components.

---

## Example: Registering a Component

```js
import { WBServices } from '../core/wb-services.js';

class WbCard extends HTMLElement {
  // ...component logic...
}

WBServices.register('wb-card', WbCard);
```

## Example: Registering a Service

```js
class ThemeService {
  setTheme(theme) { /* ... */ }
  getTheme() { /* ... */ }
}

WBServices.register('theme', new ThemeService());
```

## Example: Accessing a Service in a Component

```js
const theme = WBServices.get('theme');
theme.setTheme('dark');
```

---

## Why WBServices?

- **Consistency:** All components/services use the same registration and lookup pattern.
- **Testability:** Services can be mocked or swapped for testing.
- **Extensibility:** New services can be added without modifying existing components.
- **No Global Pollution:** Everything is managed through the registry, not global variables.

---

## Best Practices

- Always register components/services via `WBServices.register()`.
- Never extend a custom base class (use HTMLElement directly).
- Use schemas for all component properties.
- Prefer dependency injection via WBServices over direct imports for shared logic.

---

## References
- See also: `docs/claude/TIER1-LAWS.md` (Law #2)
- Architecture overview: `docs/components/README.md`
- Example usage: `src/core/wb-services.js`, `src/wb-viewmodels/`

---

## Artifacts Generated by Registration

When you register a component or service via `WBServices.register()`, the following artifacts are generated or updated (in memory):

1. **Registry Entry:**
   - The component or service is added to the central WBServices registry (an in-memory JS object or Map).
   - Includes the name (e.g., 'wb-card', 'theme') and the class or instance.

2. **Custom Element Definition (for components):**
   - For components, `customElements.define()` is called for the `<wb-*>` tag.
   - The browser recognizes the tag as a valid custom element.

3. **Schema Association (for components):**
   - The component’s JSON schema (from `src/wb-models/`) is linked to the registry entry for property validation and documentation.

4. **Service Instance (for services):**
   - For services, the singleton instance is stored and made available to all components via `WBServices.get()`.

5. **DevTools/Debug Info:**
   - The registry can be inspected at runtime for debugging, showing all registered components and services.

**Note:** No files are written to disk at runtime—these artifacts exist in memory for the duration of the app session. The registry enables dynamic lookup, dependency injection, and ensures all components/services are discoverable and testable.

### Example: Registry Entry

When you register a component or service, the registry entry might look like this (conceptually):

```js
// After WBServices.register('wb-card', WbCard)
WBServices._registry = {
   'wb-card': WbCard,
   // ...other components/services
}

// After WBServices.register('theme', new ThemeService())
WBServices._registry = {
   'wb-card': WbCard,
   'theme': ThemeServiceInstance,
   // ...
}
```

You can access these via:
```js
const CardClass = WBServices.get('wb-card');
const theme = WBServices.get('theme');
```

---

## Single Bootstrap Invocation

You only need to include `wb-bootstrap.js` once in your HTML, regardless of how many `<wb-*>` elements are present. When the script loads, it:

- Runs the bootstrap logic a single time (e.g., `WB.init()`)
- Scans the entire DOM for all `<wb-*>` elements and `x-*` attributes in one pass
- Registers and initializes every component and behavior found

This means:
- The scan and registration process happens just once, right after the script loads
- You do NOT need to include or call the bootstrapper for each component
- If new elements are added dynamically, MutationObserver logic in the bootstrapper will detect and initialize them automatically

---

## x-Behaviors: What They Are and How They Work

**x-behaviors** are attribute-based enhancements that add logic, interactivity, or effects to any element (including <wb-*> components and standard HTML tags) without requiring custom elements or class inheritance.

### What Are x-Behaviors?
- Declared as attributes like `x-ripple`, `x-tooltip`, `x-badge`, etc.
- Each x-* attribute corresponds to a behavior function defined in the behaviors registry (e.g., `src/wb-viewmodels/behaviors/`)
- Behaviors are pure functions that receive the element and options, and enhance it in place

### How Are x-Behaviors Implemented?
1. **Declaration:**
   - Add an x-* attribute to any element:
     ```html
     <button x-ripple x-tooltip="Save">Save</button>
     <wb-card x-badge="New">Card</wb-card>
     ```
2. **Scanning:**
   - On page load, the bootstrapper scans the DOM for all x-* attributes.
3. **Injection:**
   - For each x-* attribute found, the corresponding behavior function is called with the element and any options (from the attribute value).
   - Example behavior function:
     ```js
     // src/wb-viewmodels/behaviors/ripple.js
     export function ripple(element, options = {}) {
       // Add ripple effect logic here
     }
     ```
4. **Lifecycle:**
   - Behaviors can add event listeners, styles, or effects.
   - They may return a cleanup function for removal if the element is detached.

### Key Points
- x-behaviors are additive: you can use multiple on the same element.
- They work on any element, not just wb-components.
- No class inheritance or custom element registration is required for behaviors.
