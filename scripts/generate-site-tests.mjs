/**
 * generate-site-tests.mjs
 * =======================
 * Reads test.site from each component schema and generates
 * Playwright test specs for each site page.
 * 
 * Output: tests/site-generated/ (one spec per page)
 * 
 * Each spec:
 *   - Navigates to the page
 *   - Waits for WB init
 *   - Checks no critical JS errors
 *   - For each component: renders, has base class, text visible, classes applied
 */
import { readFileSync, writeFileSync, mkdirSync, existsSync } from 'fs';
import { resolve, join } from 'path';

const MODELS = resolve('src/wb-models');
const SITE_CONFIG = resolve('src/wb-models/pages/wb-component-library.site.json');
const OUTPUT_DIR = resolve('tests/site-generated');

// Ensure output dir
mkdirSync(OUTPUT_DIR, { recursive: true });

const site = JSON.parse(readFileSync(SITE_CONFIG, 'utf-8'));

// Collect schemas per page
const pageSchemas = {};

for (const page of site.pages) {
  if (!page.components) continue;
  pageSchemas[page.id] = {
    title: page.title,
    icon: page.icon || '',
    description: page.description || '',
    components: []
  };

  for (const compName of page.components) {
    const filePath = join(MODELS, `${compName}.schema.json`);
    try {
      const schema = JSON.parse(readFileSync(filePath, 'utf-8'));
      const siteTest = schema.test?.site;
      if (!siteTest) continue;
      pageSchemas[page.id].components.push({
        name: compName,
        ...siteTest,
        schemaTitle: schema.title || compName
      });
    } catch {
      console.warn(`  ⚠️  ${compName} — schema not readable`);
    }
  }
}

// Generate one test file per page
let totalTests = 0;
let totalFiles = 0;

for (const [pageId, pageData] of Object.entries(pageSchemas)) {
  const comps = pageData.components;
  if (comps.length === 0) continue;

  const lines = [];
  
  // Header
  lines.push(`/**`);
  lines.push(` * AUTO-GENERATED SITE TESTS — ${pageData.title}`);
  lines.push(` * Generated by: scripts/generate-site-tests.mjs`);
  lines.push(` * Page: demos/site/${pageId}.html`);
  lines.push(` * Components: ${comps.length}`);
  lines.push(` * DO NOT EDIT — regenerate with: node scripts/generate-site-tests.mjs`);
  lines.push(` */`);
  lines.push(`import { test, expect } from '@playwright/test';`);
  lines.push(``);
  lines.push(`const PAGE_URL = '/demos/site/${pageId}.html';`);
  lines.push(`const TIMEOUT = 10000;`);
  lines.push(``);
  lines.push(`test.describe('${pageData.icon} ${pageData.title}', () => {`);
  lines.push(``);
  
  // Track console errors
  lines.push(`  const consoleErrors: string[] = [];`);
  lines.push(``);
  lines.push(`  test.beforeEach(async ({ page }) => {`);
  lines.push(`    consoleErrors.length = 0;`);
  lines.push(`    page.on('console', msg => {`);
  lines.push(`      if (msg.type() === 'error') consoleErrors.push(msg.text());`);
  lines.push(`    });`);
  lines.push(`    page.on('pageerror', err => consoleErrors.push(err.message));`);
  lines.push(`    await page.goto(PAGE_URL, { waitUntil: 'networkidle' });`);
  lines.push(`    // Wait for WB framework to initialize`);
  lines.push(`    await page.waitForFunction(() => (window as any).WB, null, { timeout: TIMEOUT }).catch(() => {});`);
  lines.push(`    // Give behaviors time to apply`);
  lines.push(`    await page.waitForTimeout(500);`);
  lines.push(`  });`);
  lines.push(``);

  // Page-level test: loads without critical errors
  lines.push(`  test('page loads without critical errors', async ({ page }) => {`);
  lines.push(`    const title = await page.title();`);
  lines.push(`    expect(title).toBeTruthy();`);
  lines.push(`    // Allow WB-related warnings, filter for real errors`);
  lines.push(`    const criticalErrors = consoleErrors.filter(e =>`);
  lines.push(`      !e.includes('favicon') && !e.includes('404') && !e.includes('net::ERR')`);
  lines.push(`    );`);
  lines.push(`    expect(criticalErrors, \`Critical errors: \${criticalErrors.join(', ')}\`).toHaveLength(0);`);
  lines.push(`  });`);
  lines.push(``);

  // Page-level test: heading exists
  lines.push(`  test('page heading displays', async ({ page }) => {`);
  lines.push(`    const h1 = page.locator('h1');`);
  lines.push(`    await expect(h1).toBeVisible({ timeout: TIMEOUT });`);
  lines.push(`    await expect(h1).toContainText(${JSON.stringify(pageData.title.replace(/^[^\w]+/, '').trim().split(' ')[0])});`);
  lines.push(`  });`);
  lines.push(``);

  // Per-component tests
  let testCount = 2; // page-level tests
  
  for (const comp of comps) {
    const tag = comp.tag;
    const label = comp.schemaTitle;

    lines.push(`  // ── ${label} ──`);
    lines.push(`  test.describe('${label}', () => {`);

    // Test 1: Component exists on page
    lines.push(`    test('${tag} exists on page', async ({ page }) => {`);
    lines.push(`      const elements = page.locator('${tag}');`);
    lines.push(`      const count = await elements.count();`);
    lines.push(`      expect(count, '${tag} should have at least ${comp.minInstances || 1} instance(s)').toBeGreaterThanOrEqual(${Math.min(comp.minInstances || 1, 1)});`);
    lines.push(`    });`);
    testCount++;

    // Test 2: First instance renders visible
    if (comp.renders !== false) {
      lines.push(``);
      lines.push(`    test('${tag} first instance is visible', async ({ page }) => {`);
      lines.push(`      const el = page.locator('${tag}').first();`);
      lines.push(`      await expect(el).toBeVisible({ timeout: TIMEOUT });`);
      lines.push(`    });`);
      testCount++;
    }

    // Test 3: Base class applied
    if (comp.baseClass) {
      lines.push(``);
      lines.push(`    test('${tag} has base class ${comp.baseClass}', async ({ page }) => {`);
      lines.push(`      const el = page.locator('${tag}').first();`);
      lines.push(`      // WB applies base class after behavior init`);
      lines.push(`      const hasClass = await el.evaluate((node, cls) => node.classList.contains(cls), ${JSON.stringify(comp.baseClass)});`);
      lines.push(`      expect(hasClass, '${tag} should have class ${comp.baseClass}').toBe(true);`);
      lines.push(`    });`);
      testCount++;
    }

    // Test 4: Text content checks
    if (comp.checkText && comp.checkText.length > 0) {
      lines.push(``);
      lines.push(`    test('${tag} displays expected content', async ({ page }) => {`);
      lines.push(`      const allText = await page.locator('${tag}').evaluateAll(els =>`);
      lines.push(`        els.map(el => el.textContent || '').join(' ')`);
      lines.push(`      );`);
      // Check at least one text string appears
      const textChecks = comp.checkText.slice(0, 4);
      lines.push(`      const expectedTexts = ${JSON.stringify(textChecks)};`);
      lines.push(`      const found = expectedTexts.filter(t => allText.includes(t));`);
      lines.push(`      expect(found.length, \`Should find at least 1 of: \${expectedTexts.join(', ')}\`).toBeGreaterThanOrEqual(1);`);
      lines.push(`    });`);
      testCount++;
    }

    // Test 5: Variant classes applied
    if (comp.checkClasses && comp.checkClasses.length > 0) {
      lines.push(``);
      lines.push(`    test('${tag} applies variant classes', async ({ page }) => {`);
      lines.push(`      const allClasses = await page.locator('${tag}').evaluateAll(els =>`);
      lines.push(`        els.flatMap(el => [...el.classList])`);
      lines.push(`      );`);
      const classChecks = comp.checkClasses.slice(0, 3);
      lines.push(`      const expectedClasses = ${JSON.stringify(classChecks)};`);
      lines.push(`      const found = expectedClasses.filter(c => allClasses.includes(c));`);
      lines.push(`      expect(found.length, \`Should find at least 1 of: \${expectedClasses.join(', ')}\`).toBeGreaterThanOrEqual(1);`);
      lines.push(`    });`);
      testCount++;
    }

    // Test 6: Attributes present
    if (comp.checkAttributes && comp.checkAttributes.length > 0) {
      lines.push(``);
      lines.push(`    test('${tag} has expected attributes', async ({ page }) => {`);
      lines.push(`      const el = page.locator('${tag}').first();`);
      const attrs = comp.checkAttributes.slice(0, 3);
      for (const attr of attrs) {
        // Convert camelCase to kebab-case for HTML attributes
        const htmlAttr = attr.replace(/([A-Z])/g, '-$1').toLowerCase();
        lines.push(`      const has_${attr.replace(/[^a-zA-Z0-9]/g, '_')} = await el.evaluate((node, a) => node.hasAttribute(a), ${JSON.stringify(htmlAttr)});`);
        lines.push(`      expect(has_${attr.replace(/[^a-zA-Z0-9]/g, '_')}, '${tag} should have attribute "${htmlAttr}"').toBe(true);`);
      }
      lines.push(`    });`);
      testCount++;
    }

    // Test 7: Instance count matches expected
    if (comp.minInstances && comp.minInstances > 1) {
      lines.push(``);
      lines.push(`    test('${tag} has sufficient demo instances', async ({ page }) => {`);
      lines.push(`      const count = await page.locator('${tag}').count();`);
      lines.push(`      expect(count, '${tag} should have ${comp.minInstances}+ instances from matrix').toBeGreaterThanOrEqual(${Math.min(comp.minInstances, 3)});`);
      lines.push(`    });`);
      testCount++;
    }

    lines.push(`  });`);
    lines.push(``);
  }

  lines.push(`});`);
  lines.push(``);

  const filePath = join(OUTPUT_DIR, `${pageId}.spec.ts`);
  writeFileSync(filePath, lines.join('\n'));
  console.log(`  ✅ ${pageId}.spec.ts — ${comps.length} components, ~${testCount} tests`);
  totalTests += testCount;
  totalFiles++;
}

// Write summary
const summary = {
  generated: new Date().toISOString(),
  files: totalFiles,
  totalTests,
  outputDir: OUTPUT_DIR
};
writeFileSync(resolve('data/site-tests-generated.json'), JSON.stringify(summary, null, 2));

console.log(`\n══════════════════════════════`);
console.log(`  Files: ${totalFiles}`);
console.log(`  Tests: ~${totalTests}`);
console.log(`  Output: tests/site-generated/`);
console.log(`══════════════════════════════`);
