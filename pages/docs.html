<link rel="stylesheet" href="../src/styles/pages/docs.css">

<div id="docs-hero" class="page__hero">
  <h1>üìñ Documentation</h1>
  <p>Browse all documentation, guides, and research papers.</p>
  <div class="docs-search-wrapper">
    <input type="search" id="docs-search" placeholder="Search documentation...">
    <span class="docs-search-icon">üîç</span>
  </div>
</div>

<div id="docs-container" class="page__section">
  <div id="docs-loading" class="docs-loading">
    <wb-spinner></div>
    <p>Loading documentation...</p>
  </div>
</div>

<script>
  // Self-executing function (no module needed)
  (async function loadDocs() {
    const container = document.getElementById('docs-container');
    const searchInput = document.getElementById('docs-search');
    if (!container) return;
    
    let fullManifest = null;

    function renderDocs(manifestData) {
      if (!manifestData || !manifestData.categories) {
        container.innerHTML = '<p style="text-align: center; color: var(--text-muted);">No documentation found.</p>';
        return;
      }

      let html = '';
      let hasResults = false;
      
      for (const category of manifestData.categories) {
        // Skip empty categories after filtering
        const hasDocs = category.docs && category.docs.length > 0;
        const hasPages = category.pages && category.pages.length > 0;
        
        if (!hasDocs && !hasPages) continue;
        
        hasResults = true;
        html += '<div class="docs-category" style="margin-bottom: 2.5rem;">';
        html += '<h2 style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 1rem;">';
        html += '<span>' + category.icon + '</span>';
        html += '<span>' + category.name + '</span>';
        html += '</h2>';
        html += '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 1rem;">';
        
        // Handle markdown docs
        if (category.docs) {
          for (const doc of category.docs) {
            // Use absolute path for doc-viewer
            const filePath = doc.file.startsWith('http') || doc.file.startsWith('/') ? doc.file : '/docs/' + doc.file;
            html += '<a href="/doc-viewer.html?file=' + encodeURIComponent(filePath) + '" ';
            html += 'class="docs-card" target="_blank" ';
            html += 'style="display: block; padding: 1.25rem; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 10px; text-decoration: none; color: inherit; transition: all 0.2s;">';
            html += '<h3 style="margin: 0 0 0.5rem; color: var(--primary); font-size: 1rem;">' + doc.title + '</h3>';
            html += '<p style="margin: 0; font-size: 0.875rem; color: var(--text-muted);">' + doc.description + '</p>';
            html += '</a>';
          }
        }
        
        // Handle page links (like research papers)
        if (category.pages) {
          for (const page of category.pages) {
            html += '<a href="/pages/' + page.page + '.html" ';
            html += 'class="docs-card" target="_blank" ';
            html += 'style="display: block; padding: 1.25rem; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 10px; text-decoration: none; color: inherit; transition: all 0.2s;">';
            html += '<h3 style="margin: 0 0 0.5rem; color: var(--primary); font-size: 1rem;">' + page.title + '</h3>';
            html += '<p style="margin: 0; font-size: 0.875rem; color: var(--text-muted);">' + page.description + '</p>';
            html += '</a>';
          }
        }
        
        html += '</div></div>';
      }
      
      if (!hasResults) {
        container.innerHTML = '<div style="text-align: center; padding: 3rem; color: var(--text-muted);">' +
          '<p style="font-size: 1.5rem; margin-bottom: 0.5rem;">üîç</p>' +
          '<p>No results found matching your search.</p>' +
          '</div>';
      } else {
        container.innerHTML = html;
        
        // Add hover effects
        container.querySelectorAll('.docs-card').forEach(function(card) {
          card.addEventListener('mouseenter', function() {
            card.style.transform = 'translateY(-2px)';
            card.style.borderColor = 'var(--primary)';
            card.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
          });
          card.addEventListener('mouseleave', function() {
            card.style.transform = '';
            card.style.borderColor = 'var(--border-color)';
            card.style.boxShadow = '';
          });
        });
      }
    }

    function filterManifest(query) {
      if (!query) return fullManifest;
      
      const lowerQuery = query.toLowerCase();
      const filteredCategories = fullManifest.categories.map(cat => {
        const filteredDocs = (cat.docs || []).filter(doc => 
          doc.title.toLowerCase().includes(lowerQuery) || 
          doc.description.toLowerCase().includes(lowerQuery)
        );
        
        const filteredPages = (cat.pages || []).filter(page => 
          page.title.toLowerCase().includes(lowerQuery) || 
          page.description.toLowerCase().includes(lowerQuery)
        );
        
        return {
          ...cat,
          docs: filteredDocs,
          pages: filteredPages
        };
      }).filter(cat => 
        (cat.docs && cat.docs.length > 0) || 
        (cat.pages && cat.pages.length > 0)
      );
      
      return { ...fullManifest, categories: filteredCategories };
    }
    
    try {
      const res = await fetch('docs/manifest.json');
      if (!res.ok) throw new Error('Failed to fetch manifest');
      fullManifest = await res.json();
      
      // Check for query param
      const urlParams = new URLSearchParams(window.location.search);
      const query = urlParams.get('q');
      
      if (query && searchInput) {
        searchInput.value = query;
        const filtered = filterManifest(query);
        renderDocs(filtered);
      } else {
        renderDocs(fullManifest);
      }

      if (searchInput) {
        searchInput.addEventListener('input', (e) => {
          const filtered = filterManifest(e.target.value);
          renderDocs(filtered);
        });
      }
      
    } catch (err) {
      console.error('Failed to load docs manifest:', err);
      container.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-muted);">' +
        '<p>‚ö†Ô∏è Could not load documentation index.</p>' +
        '<p style="font-size: 0.875rem;">Error: ' + err.message + '</p>' +
        '</div>';
    }
  })();
</script>
