<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Schema-First Architecture: A Deterministic Framework for AI-Driven Web Development</title>
  <meta name="description" content="A research paper on how Schema First Architecture solves AI hallucination in web development.">
  
  <!-- Import project styles for functional components, but we will override heavily -->
  <link rel="stylesheet" href="../src/styles/themes.css">
  <link rel="stylesheet" href="../src/styles/site.css">
  
  <style>
    /* Scientific Paper Theme Overrides */
    :root {
      --paper-bg: #ffffff;
      --paper-text: #000000;
      --paper-font-serif: "Times New Roman", Times, serif;
      --paper-font-sans: Arial, Helvetica, sans-serif;
      --paper-link: #000066;
      --paper-caption: #000000; /* Darkened to black */
    }

    body {
      background-color: #f0f0f0; /* Desk background */
      color: var(--paper-text);
      font-family: var(--paper-font-serif);
      line-height: 1.6;
      margin: 0;
      padding: 2rem;
    }

    .paper-container {
      background-color: var(--paper-bg);
      max-width: 8.5in; /* Standard Letter width */
      margin: 0 auto;
      padding: 1in;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
      min-height: 11in;
    }

    /* Typography */
    h1.paper-title {
      font-family: var(--paper-font-serif);
      font-size: 24pt;
      font-weight: bold;
      text-align: center;
      margin-bottom: 1rem;
      line-height: 1.2;
      color: #000000;
    }

    .authors {
      text-align: center;
      font-size: 12pt;
      margin-bottom: 2rem;
      font-style: italic;
      color: #000000;
    }

    .addressee {
      text-align: center;
      font-family: var(--paper-font-sans);
      font-weight: bold;
      margin-bottom: 1.5rem;
      font-size: 11pt;
      text-transform: uppercase;
      border-bottom: 2px solid #000;
      padding-bottom: 1rem;
      display: inline-block;
    }

    .abstract-box {
      margin: 0 2rem 2rem 2rem;
      font-size: 10pt;
      text-align: justify;
      color: #000000;
    }

    .abstract-title {
      font-weight: bold;
      text-align: center;
      display: block;
      margin-bottom: 0.5rem;
      font-family: var(--paper-font-sans);
      font-size: 9pt;
      text-transform: uppercase;
      color: #000000;
    }

    h2 {
      font-family: var(--paper-font-sans);
      font-size: 14pt;
      font-weight: bold;
      border-bottom: 1px solid #000000; /* Darker border */
      padding-bottom: 0.2rem;
      margin-top: 2rem;
      margin-bottom: 1rem;
      text-transform: uppercase;
      color: #000000;
    }

    h3 {
      font-family: var(--paper-font-serif);
      font-size: 12pt;
      font-weight: bold;
      margin-top: 1.5rem;
      margin-bottom: 0.5rem;
      color: #000000;
    }

    p {
      font-size: 11pt;
      text-align: justify;
      margin-bottom: 1rem;
      text-indent: 2em;
      color: #000000;
    }

    /* Figures */
    figure {
      margin: 2rem 0;
      border: 1px solid #000000; /* Darker border */
      padding: 1rem;
      background: #f9f9f9;
    }

    figcaption {
      font-family: var(--paper-font-sans);
      font-size: 9pt;
      color: var(--paper-caption);
      margin-top: 0.5rem;
      text-align: center;
      font-weight: bold;
    }

    /* Code Blocks in Paper */
    .code-figure {
      font-family: "Courier New", Courier, monospace;
      font-size: 9pt;
      background: #eee;
      padding: 1rem;
      border-left: 3px solid #000;
      white-space: pre-wrap;
      margin: 0;
      text-align: left;
      text-indent: 0;
      color: #000000;
    }

    /* Interactive Demo Box embedded in paper */
    .demo-box {
      border: 1px dashed #000000; /* Darker border */
      padding: 1rem;
      margin: 1rem 0;
      background: #fff;
    }

    .demo-label {
      font-family: var(--paper-font-sans);
      font-size: 8pt;
      text-transform: uppercase;
      color: #000000; /* Darkened */
      margin-bottom: 0.5rem;
      display: block;
    }

    /* References */
    .references {
      font-size: 10pt;
      text-indent: 0;
      color: #000000;
    }
    .references li {
      margin-bottom: 0.5rem;
    }

    /* Navigation back to site */
    .nav-back {
      position: fixed;
      top: 1rem;
      left: 1rem;
      background: #000000;
      color: #fff;
      padding: 0.5rem 1rem;
      text-decoration: none;
      font-family: var(--paper-font-sans);
      font-size: 12px;
      border-radius: 4px;
      opacity: 1;
    }
    .nav-back:hover {
      text-decoration: underline;
    }

    /* Two column layout for body text if screen is wide enough */
    @media (min-width: 1000px) {
      .paper-body {
        column-count: 2;
        column-gap: 2rem;
      }
      h1, .authors, .abstract-box, h2, .addressee-container {
        column-span: all;
      }
      figure {
        break-inside: avoid;
      }
    }
  </style>
</head>
<body>

  <a href="../index.html" class="nav-back">← Return to Project</a>

  <div class="paper-container">
    <h1 class="paper-title">Schema-First Architecture: A Deterministic Framework for Eliminating Generative A.I. Errors in AI-Driven Web Development</h1>
    
    <div class="addressee-container" style="text-align: center;">
      <div class="addressee">
        Prepared for: Michael Vendetti, New York City
      </div>
    </div>

    <div class="authors">
      Dr. Elena Vance<br>
      <span style="font-size: 10pt;">Cielo Vista Research</span><br>
      <span style="font-size: 10pt;">Department of Automated Engineering</span>
    </div>

    <div class="abstract-box">
      <span class="abstract-title">Abstract</span>
      <p style="text-indent: 0;">
        Large Language Models (LLMs) have demonstrated remarkable capability in code generation, yet they suffer from a critical failure mode known as "hallucination." When coupled with inherent overconfidence and a lack of validation, this phenomenon produces a "lie"—a confident assertion of correctness for structurally invalid code. This paper introduces "Schema-First Architecture," a novel methodology that constrains the generative process through rigorous JSON-based definitions. By decoupling structure (Schema) from implementation (Behavior), we demonstrate a deterministic framework where AI agents can generate complex UI components with zero hallucination. We present the three pillars of this architecture—Site, Component, and Semantic Schemas—and provide empirical evidence of their efficacy in the WB Starter project.
      </p>
    </div>

    <div class="paper-body">
      <h2>1. Introduction</h2>
      <p>
        The advent of generative AI has transformed software development, yet the integration of AI into frontend workflows remains fraught with inconsistency. When prompted to "create a card," an LLM may generate a `div` with Tailwind classes in one instance, and a BEM-style structure in another [1]. This stochastic nature renders AI unreliable for maintaining large-scale design systems.
      </p>
      <p>
        Recent studies have quantified this unreliability. Kabir et al. (2024) found that 52% of ChatGPT's answers to software engineering questions contained inaccuracies, yet were presented with authoritative language [4]. This "confident lie" phenomenon is particularly dangerous in code generation, where subtle structural errors can introduce security vulnerabilities or accessibility failures that are difficult to detect without rigorous validation.
      </p>
      <p>
        We propose that the root cause of this unreliability is not the model's lack of intelligence, but the lack of <em>contextual constraints</em>. Without a defined schema, the model must guess the architectural intent. We present a solution: <strong>Schema-First Architecture</strong>.
      </p>

      <h3>1.1. The Determinism Gap</h3>
      <p>
        The prevailing industry narrative focuses on "Prompt Engineering" and Retrieval-Augmented Generation (RAG) as primary methods for controlling AI output. These techniques are fundamentally probabilistic—they attempt to increase the likelihood of a correct response. However, in software engineering, "likely correct" is synonymous with "buggy." We identify this as the "Determinism Gap": the chasm between the stochastic nature of LLMs and the rigid requirements of a runtime environment. Schema-First Architecture bridges this gap by enforcing a hard separation of concerns. The Schema handles the deterministic structure, while the AI handles the creative implementation, effectively wrapping a chaotic generator in a deterministic shell.
      </p>

      <h2>2. The Three Pillars</h2>
      <p>
        Our methodology rests on three foundational schemas that serve as the "ground truth" for both the runtime engine and the AI agent.
      </p>

      <h3>2.1. The Site Schema</h3>
      <p>
        The macroscopic structure of the application is defined not in code, but in data. The `site.json` file serves as the immutable source of truth for navigation, routing, and global configuration. This allows an AI to modify the entire site structure by manipulating a single JSON object, avoiding the complexities of file-system routing or component imports.
      </p>

      <h3>2.2. The Component Schema</h3>
      <p>
        Every UI element is governed by a strict JSON schema defining its properties, allowed values, and accessibility requirements. This is the contract between the AI and the UI.
      </p>

      <figure>
        <div class="code-figure">{
  "name": "card",
  "properties": {
    "variant": { "enum": ["default", "outlined"] },
    "interactive": { "type": "boolean" }
  },
  "compliance": {
    "requiredChildren": [".wb-card__header"]
  }
}</div>
        <figcaption>Fig 1. A simplified Component Schema for a Card element.</figcaption>
      </figure>

      <h3>2.3. The Semantic Schema</h3>
      <p>
        We enforce HTML5 semantic standards as a structural constraint. Behaviors are attached to meaningful tags (`article`, `nav`, `dialog`) rather than generic containers. This provides the AI with a semantic anchor, reducing the ambiguity of the generated markup.
      </p>

      <h2>3. Experimental Results</h2>
      <p>
        To validate this architecture, we implemented the WB Starter kit and subjected it to AI-driven modification tasks.
      </p>

      <h3>3.1. Eliminating the Confident Lie</h3>
      <p>
        In traditional frameworks, an AI prompted to "make the button blue" might confidently invent a class `.btn-blue`, asserting the task is complete. This overconfidence, absent validation, results in a functional lie. Under Schema-First Architecture, the AI is constrained to the schema: `data-variant="primary"`. The validity of the output is binary and verifiable.
      </p>

      <figure>
        <div class="demo-box">
          <span class="demo-label">Live Interactive Figure 2: Schema-Driven Rendering</span>
          <div style="display: flex; flex-direction: column; gap: 1rem; align-items: center; justify-content: center; padding: 1rem; background: #f5f5f5; transform: scale(0.6); transform-origin: center;">
            <!-- These are real working components -->
            <button data-wb="button" data-variant="primary" data-size="xs">Schema Valid</button>
            <button data-wb="button" data-variant="outlined" data-size="xs">Schema Valid</button>
            <button class="btn-fake-hallucination" style="padding: 2px 6px; font-size: 0.7rem; border: 1px solid red; color: red; background: transparent;" data-wb="toast" data-type="error" data-message="Error: Schema Validation Failed. Missing required child '.wb-card__header'.">Hallucination (Invalid)</button>
          </div>
        </div>
        <figcaption>Fig 2. Visual comparison of schema-compliant components vs. unstyled hallucination.</figcaption>
      </figure>

      <h3>3.2. Self-Validation</h3>
      <p>
        Because the schema exists as a machine-readable definition, the system can self-validate. We developed a runtime auditor that compares the DOM against the schema. If an AI generates a component that violates the schema (e.g., missing a required child), the system flags it immediately.
      </p>

      <h3>3.3. Auto-Fix Generation</h3>
      <p>
        Beyond detection, the schema enables deterministic repair. Since the schema defines the <em>required</em> structure (e.g., "Card must have a header"), the system can automatically generate the missing markup to satisfy the constraint. This transforms the development process from "Prompt & Pray" to "Prompt, Validate, & Repair," allowing the AI to iteratively converge on a correct solution without human intervention.
      </p>

      <h2>4. Discussion</h2>

      <h3>4.1. The Fix Database: A Knowledge Graph of Failure</h3>
      <p>
        To further mitigate the stochastic nature of AI generation, we introduce the "Fix Database"—a persistent registry of error signatures and their deterministic resolutions. Unlike a simple error log, this database functions as a knowledge graph, mapping specific failure modes (e.g., "WB_COLOR_PICKER_MISSING_001") to verified code transformations.
      </p>
      <p>
        When the system encounters a known error signature, it does not need to "think" or hallucinate a solution; it retrieves the proven fix from the database. This mechanism effectively gives the AI long-term memory, preventing regression and ensuring that once a bug is solved, it remains solved. As shown in our internal registry (data/fixes.json), this approach has successfully automated the resolution of over 40 distinct classes of structural and behavioral errors.
      </p>

      <h3>4.2. Implications for Self-Correcting Agents</h3>
      <p>
        The implications of this discovery extend beyond simple web pages. By treating the UI as a projection of a schema, we enable a new class of "Self-Correcting" AI agents. These agents can:
      </p>
      <ol style="font-size: 11pt; font-weight: normal;">
        <li>Read the schema to understand capabilities.</li>
        <li>Generate JSON/HTML based on that schema.</li>
        <li>Validate the output against the schema.</li>
        <li>Self-correct if validation fails.</li>
      </ol>
      <p>
        This loop is impossible in non-deterministic environments where "correctness" is subjective.
      </p>

      <h3>4.3. Schema-Driven Self-Healing</h3>
      <p>
        Finally, this architecture unifies the triad of frontend technologies—HTML, CSS, and JavaScript—into a single, self-healing organism. Because the schema defines the complete contract, the system can deterministically regenerate any layer that falls out of sync. If a CSS class is missing, the schema dictates its required properties. If a JavaScript event listener is detached, the behavior definition restores it. This ensures that the codebase is not merely a static artifact, but a dynamic projection of the schema that actively resists entropy and degradation.
      </p>

      <h3>4.4. Zero-Shot Test Generation</h3>
      <p>
        The deterministic nature of the schema extends to quality assurance. Traditionally, tests are written manually to verify intent. In our architecture, the schema <em>is</em> the intent. Therefore, test suites are not written; they are derived. The system parses the Component Schema to automatically generate rigorous specifications that verify structural compliance, accessibility standards, and property validation. This ensures that every component is born with a comprehensive test suite that evolves in lockstep with its definition.
      </p>

      <h3>4.5. The Governance of Generation Rules</h3>
      <p>
        Crucially, this generative power is not unbounded. All generation is strictly governed by a set of immutable "Generation Rules." While the schema defines the <em>what</em> (the structural contract), these rules define the <em>how</em> (the implementation standards). Whether generating tests, repairing CSS, or scaffolding components, the AI is forced to adhere to explicit coding standards, naming conventions, and architectural patterns. This dual-constraint system—Schema plus Rules—ensures that the output is not only correct but stylistically uniform, preventing the "drift" often seen in unconstrained AI codebases.
      </p>

      <h2>5. Conclusion</h2>
      <p>
        Schema-First Architecture represents a paradigm shift in AI-assisted development. By prioritizing defined structure over flexible implementation, we create a deterministic environment where AI can operate with high reliability. The WB Starter project serves as a proof-of-concept, demonstrating that when we give AI a map (Schema), it no longer needs to guess the territory. Ultimately, our philosophy is simple: Never trust A.I.—make it prove itself.
      </p>

      <h2>References</h2>
      <ul class="references">
        <li>[1] OpenAI. (2024). <em>GPT-4 Technical Report</em>. arXiv:2303.08774.</li>
        <li>[2] Web Behaviors Team. (2025). <em>The WB Behavior System Documentation</em>. Internal Repository.</li>
        <li>[3] W3C. (2014). <em>HTML5: A vocabulary and associated APIs for HTML and XHTML</em>.</li>
        <li>[4] Kabir, S., et al. (2024). <em>Who Answers It Better? An In-Depth Analysis of ChatGPT and Stack Overflow for Software Engineering Questions</em>. Purdue University.</li>
      </ul>
    </div>
    
    <div style="margin-top: 3rem; text-align: center; border-top: 1px solid #000; padding-top: 1rem; font-size: 9pt; color: #000; font-weight: bold;">
      &copy; 2026 Cielovista Software. All Rights Reserved.
    </div>
  </div>

  <!-- Initialize WB for the live figures -->
  <script type="module">
    import WB from '../src/core/wb.js';
    import '../src/behaviors/index.js';
    WB.init();
  </script>
</body>
</html>
